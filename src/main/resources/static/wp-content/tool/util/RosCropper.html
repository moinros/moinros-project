<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
    <title>图片裁剪工具</title>
    <style>
        .RosCropping {
            width: 1000px;
            margin: auto;
        }

        .crop-box-wrap {
            position: relative;
            width: 1000px;
        }

        .native-box, .crop-masking, .preview-box {
            width: 100%;
            height: 100%;
            position: absolute;
            user-select: none;
        }

        .native-box img {
            width: 100%;
        }

        .crop-masking {
            background-color: #666666;
            opacity: 0.5;
        }

        .preview-box img {
            position: absolute;
            clip: rect(0px, 100px, 100px, 0px);
        }

        .drag-point {
            width: 7px;
            height: 7px;
            position: absolute;
            background-color: white;
            border: 1px solid #ffffff;
            opacity: 0.6;
        }

        .drag-point:active {
            border: 1px solid #292aff;
        }

        .drag-box {
            position: absolute;
            width: 100px;
            height: 100px;
            display: none;
            cursor: move;
            user-select: none;
            box-shadow: 0px 0px 1px 1px #fafafa;
        }

        .drag-box:active {
            box-shadow: 0px 0px 1px 1px #292aff;
        }

        .point-n {
            top: -5px;
            left: calc(50% - 5px);
        }

        .point-e {
            right: -5px;
            top: calc(50% - 5px);
        }

        .point-s {
            bottom: -5px;
            left: calc(50% - 5px);
        }

        .point-w {
            left: -5px;
            top: calc(50% - 5px);
        }

        .point-ne {
            cursor: nesw-resize;
            right: -5px;
            top: -5px;
        }

        .point-se {
            cursor: nwse-resize;
            right: -5px;
            bottom: -5px;
        }

        .point-nw {
            cursor: nwse-resize;
            left: -5px;
            top: -5px;
        }

        .point-sw {
            cursor: nesw-resize;
            left: -5px;
            bottom: -5px;
        }
    </style>
</head>
<body>
<div class="RosCropping">
    <div class="crop-box-wrap" id="crop_box_wrap">
        <div class="native-box" id="native_box">
            <!-- 本地图片预览 <img src=""/> -->
        </div>
        <!-- 遮罩层 -->
        <div class="crop-masking" id="crop_masking"></div>
        <!-- 拖拽框中的预览图 -->
        <div class="preview-box" id="preview_box"></div>
        <!-- 拖拽框 -->
        <div class="drag-box" id="drag_box">
            <div id="point_n" class="drag-point point-n" tips="北"></div>
            <div id="point_e" class="drag-point point-e" tips="东"></div>
            <div id="point_s" class="drag-point point-s" tips="南"></div>
            <div id="point_w" class="drag-point point-w" tips="西"></div>
            <div id="point_ne" class="drag-point point-ne" tips="东北"></div>
            <div id="point_se" class="drag-point point-se" tips="东南"></div>
            <div id="point_nw" class="drag-point point-nw" tips="西北"></div>
            <div id="point_sw" class="drag-point point-sw" tips="西南"></div>
        </div>
    </div>
    <!-- 文件选择框 -->
    <div><input id="select_input" type="file" value="图片上传"/></div>
    <div id="show_img"></div>
    <div><input id="save_input" type="button" value="裁剪图片"/></div>
</div>
<script>

    (function() {

        // 提取出'getDom'方法,省略获取DOM节点的重复代码
        function getDom(id) {
            return document.getElementById(id);
        }

        // 将指定的DOM元素从DOM树中移除
        function removeElement(ele) {
            if (ele) ele.parentNode.removeChild(ele);
        }

        const cropBoxWrap = getDom("crop_box_wrap");
        // 本地图片预览框
        const nativeBox = getDom("native_box");
        // 遮罩层
        const masking = getDom("crop_masking");
        // 拖拽框
        const dragBox = getDom("drag_box");
        // 拖拽框中的图片
        const previewBox = getDom("preview_box");
        // 文件选择框
        const selectInput = getDom("select_input");
        // 文件选择框
        const saveInput = getDom("save_input");
        // 存放本地图片
        let nativeImage;
        // 存放拖拽框中的预览图
        let viewImage;

        saveInput.onmousedown = function() {
            console.log(nativeImage.naturalWidth + "  -  " + nativeImage.naturalHeight);

            let view = document.createElement("canvas");
            let ctx = view.getContext("2d");
            if (ctx) {
                let width = nativeImage.naturalWidth;
                let height = nativeImage.naturalHeight;
                view.width = width;
                view.height = height;

                // 原图按照原始尺寸添加到画布上
                ctx.drawImage(nativeImage, 0, 0, width, height);
                // 保存画布状态
                ctx.save();
                //
                let offset = (width / nativeImage.width);
                let dx = offset * dragBox.offsetLeft;
                let dy = offset * dragBox.offsetTop;
                let dw = offset * dragBox.offsetWidth;
                let dh = offset * dragBox.offsetHeight;


                let data = ctx.getImageData(dx, dy, dw, dh);
                view.width = dw;
                view.height = dh;
                ctx.putImageData(data, 0, 0);
                let image = new Image(dw, dh);
                image.src = view.toDataURL("image/jpeg");
                getDom("show_img").appendChild(image);
                console.log(dataURLtoFile(view.toDataURL("image/jpeg"), "image.jpeg"));
                image.onload = function() {
                    console.log(image.src);
                    image.onclick = function() {
                        uploadFile(this);
                    }
                }
            }

        }

        function uploadFile(image) {
            let form = document.createElement('form');

            form.setAttribute('enctype', 'multipart/form-data');
            form.method = 'post';


            let formData = new FormData(form);
            let file = dataURLtoFile(image.src, "moinros-tou.jpeg");
            formData.append("file", file);
            Ajax.post(formData, "https://www.server-file.com/server/file/upload/binary/face");
        }


        const Ajax = {
            post: function(data, url) {
                let xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4 && xhr.status == 200) {
                        console.log(xhr.responseText);
                    }
                };
                xhr.open('POST', url);
                xhr.send(data);
            }
        };

        function dataURLtoFile(dataurl, filename) {//将base64转换为文件
            let arr = dataurl.split(',');
            let mime = arr[0].match(/:(.*?);/)[1];
            let bstr = atob(arr[1]);
            let n = bstr.length;
            let u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new File([u8arr], filename, {type: mime});
        }


        // 按下鼠标时移动拖拽框实现裁剪图片的预览
        // dragBox.onmousedown = function(ev) {
        //     console.log("拖拽框");
        //     // 'clientX'和'clientY'获取的是鼠标点击瞬间相对于网页可视区域左方和上方的距离
        //     // 'offsetLeft'和'offsetTop'获取的鼠标点击的元素以左上角为基准距离父定位元素的边距
        //     // 由于裁剪模块在页面中的位置是不固定的,
        //     // 所以此处先用按下鼠标时的坐标,减去拖拽框相对于父元素的坐标,从而计算出一个定位坐标
        //     // 鼠标移动时就可以根据这个定位坐标计算拖拽框的准确坐标
        //     //    let diffX = e.clientX - dragBox.offsetLeft; // 拖拽框定位X坐标
        //     //     let diffY = e.clientY - dragBox.offsetTop; // 拖拽框定位Y坐标
        //     //  console.log("clientX = " + e.clientX + " - e.clientY = " + diffY);
        //     //   console.log("offsetLeft = " + dragBox.offsetLeft + " - offsetTop = " + dragBox.offsetTop);
        //     //   console.log("diffX = " + diffX + " - diffY = " + diffY);
        //
        //     //   let dw = dragBox.offsetWidth; // 拖拽框宽度
        //     //   let dh = dragBox.offsetHeight; // 拖拽框高度
        //     // 按下鼠标后移动鼠标时触发
        //
        //     let coor = getCoordinate(ev);
        //     document.onmousemove = function(e) {
        //         let x = coor.diffX - e.clientX;
        //         let y = coor.diffY - e.clientY;
        //
        //         dragBox.style.left = (coor.dx - x < 0 ? 0 : coor.dx - x > nativeImage.width - coor.DW ? nativeImage.width - coor.DW : coor.dx - x) + 'px';
        //         dragBox.style.top = (coor.dy - y < 0 ? 0 : coor.dy - y > nativeImage.height - coor.DH ? nativeImage.height - coor.DH : coor.dy - y) + 'px';
        //
        //         // 用鼠标当前坐标减去定位坐标,即可得出预览框相对于父元素的坐标位置
        //         // let left = e.clientX - diffX;
        //         // let top = e.clientY - diffY;
        //         //
        //         // // left小于0时说明拖拽框已经移动到了父元素外,top同理
        //         // // 此时设置left=0,即可实现拖拽框在指定范围内移动
        //         // if (left < 0) left = 0;
        //         // if (top < 0) top = 0;
        //         // // 由于是以拖拽框的左上角为基准所以计算右方和下方的距离时还要减去拖拽框自身的宽度和高
        //         // if (left + dw > nativeImage.width) left = nativeImage.width - dw;
        //         // if (top + dh > nativeImage.height) top = nativeImage.height - dh;
        //         //
        //         // // 计算完成后设置拖拽的框的相对坐标,实现拖拽框的移动
        //         // dragBox.style.left = left + 'px';
        //         // dragBox.style.top = top + 'px';
        //
        //         // 设置画布图片的可视区域
        //         setClip();
        //     };
        //     //当鼠标弹起来时触发 
        //     document.onmouseup = mouseUpClose;
        // };

        let flag = true;

        /**
         * 为元素绑定鼠标点击事件
         */
        function setEvent(ele, fn) {
            ele.onmousedown = function(ev) {
                if (flag) {
                    flag = false;
                    //      console.log(ele);
                    let coor = getCoordinate(ev);
                    document.onmousemove = function(e) {
                        coor.x = coor.diffX - e.clientX;
                        coor.y = coor.diffY - e.clientY;
                        fn(coor, e);
                        setClip();
                    };
                    document.onmouseup = function(e) {
                        document.onmousemove = null;
                        e.preventDefault();
                        flag = true;
                    };
                }
            }
        }

        setEvent(dragBox, function(coor, e) {
            dragBox.style.left = (coor.dx - coor.x < 0 ? 0 : coor.dx - coor.x > nativeImage.width - coor.DW ? nativeImage.width - coor.DW : coor.dx - coor.x) + 'px';
            dragBox.style.top = (coor.dy - coor.y < 0 ? 0 : coor.dy - coor.y > nativeImage.height - coor.DH ? nativeImage.height - coor.DH : coor.dy - coor.y) + 'px';
        });

        /**
         * 设置背景图的Clip坐标,实现预览框在背景图上的滑动;<br>
         * 我使用的是CSS的[ clip: rect(top, right, bottom, left) ]属性来实现拖拽框中的预览图;<br>
         * 根据W3C文档中的说法:这个属性用于定义一个剪裁矩形。对于一个绝对定义元素，在这个矩形内的内容才可见;<br>
         * 出了这个剪裁区域的内容会根据[ overflow ]的值来处理.剪裁区域可能比元素的内容区大,也可能比内容区小;<br>
         * 注意事项:使用[ clip ]属性时,不能设置[ overflow:visible; ];<br>
         * 同时必须设置[ position: absolute; ]或者[ position: fixed; ]<br>
         */
        function setClip() {
            // 此处只要将画布的clip: rect 的4个属性设置为拖拽框的4个边距,即可实现拖拽框中图片的预览
            let top = dragBox.offsetTop;
            let right = dragBox.offsetLeft + dragBox.offsetWidth;
            let bottom = dragBox.offsetTop + dragBox.offsetHeight;
            let left = dragBox.offsetLeft;
            viewImage.style.clip = 'rect(' + top + 'px, ' + right + 'px, ' + bottom + 'px, ' + left + 'px)';
        }

        // 东北
        let pointNE = document.getElementById("point_ne");
        setEvent(pointNE, function(coor, e) {
            moveRight(coor, coor.x, coor.y);
            moveTop(coor, coor.x, coor.y);
            scaling(getValueMin((nativeImage.width - coor.dx), (coor.dy + dragBox.offsetHeight)));
            limitTop(coor, coor.x, coor.y);
            dragBox.style.left = (coor.dx) + 'px';
            dragBox.style.top = (coor.dy + coor.DH - dragBox.offsetHeight) + 'px';
        });
        // pointNE.onmousedown = function(ev) {
        //     console.log("缩放点");
        //     let coor = getCoordinate(ev);
        //     document.onmousemove = function(e) {
        //         let dw = coor.diffX - e.clientX;
        //         let dh = coor.diffY - e.clientY;
        //         // dragBox.style.width = (coor.DW - dw > nativeImage.width - coor.dx ? nativeImage.width - coor.dx : coor.DW - dw) + 'px';
        //         // dragBox.style.height = (coor.DH + dh > coor.DH + coor.dy ? coor.DH + coor.dy : coor.DH + dh) + 'px';
        //         // dragBox.style.top = (coor.dy - dh < 0 ? 0 : coor.dy - dh) + 'px';
        //         moveRight(coor, dw, dh);
        //         moveTop(coor, dw, dh);
        //         limitTop(coor, dw, dh);
        //         setClip();
        //     }
        //     document.onmouseup = mouseUpClose;
        // }

        // 东南
        let pointSE = document.getElementById("point_se");
        setEvent(pointSE, function(coor, e) {
            moveRight(coor, coor.x, coor.y);
            moveDown(coor, coor.x, coor.y);
            scaling(getValueMin((nativeImage.width - coor.dx), (nativeImage.height - coor.dy)));
            dragBox.style.left = (coor.dx) + 'px';
            dragBox.style.top = (coor.dy) + 'px';
        });
        // pointSE.onmousedown = function(ev) {
        //     console.log("缩放点");
        //     let coor = getCoordinate(ev);
        //     document.onmousemove = function(e) {
        //
        //         let dw = coor.diffX - e.clientX;
        //         let dh = coor.diffY - e.clientY;
        //         // dragBox.style.width = (coor.DW - dw > nativeImage.width - coor.dx ? nativeImage.width - coor.dx : coor.DW - dw) + 'px';
        //         // dragBox.style.height = (coor.DH - dh > nativeImage.height - coor.dy ? nativeImage.height - coor.dy : coor.DH - dh) + 'px';
        //         moveRight(coor, coor.x, coor.y);
        //         moveDown(coor, coor.x, coor.y);
        //         setClip();
        //     }
        //     document.onmouseup = mouseUpClose;
        // }

        // 西北
        let pointNW = document.getElementById("point_nw");
        setEvent(pointNW, function(coor, e) {
            moveLeft(coor, coor.x, coor.y);
            moveTop(coor, coor.x, coor.y);
            scaling(getValueMin((coor.dx + dragBox.offsetWidth), (coor.dy + dragBox.offsetHeight)));
            limitTop(coor, coor.x, coor.y);
            limitLeft(coor, coor.x, coor.y);
            dragBox.style.left = (coor.dx + coor.DW - dragBox.offsetWidth) + 'px';
            dragBox.style.top = (coor.dy + coor.DH - dragBox.offsetHeight) + 'px';

        });
        // pointNW.onmousedown = function(ev) {
        //     console.log("缩放点");
        //     let coor = getCoordinate(ev);
        //     document.onmousemove = function(e) {
        //
        //         let dw = coor.diffX - e.clientX;
        //         let dh = coor.diffY - e.clientY;
        //         // dragBox.style.width = (dw > coor.dx) ? coor.dx + coor.DW : (dw + coor.DW) + 'px';
        //         // dragBox.style.height = (coor.DH + dh > coor.DH + coor.dy ? coor.DH + coor.dy : coor.DH + dh) + 'px';
        //         // dragBox.style.top = (coor.dy - dh < 0 ? 0 : coor.dy - dh) + 'px';
        //         // dragBox.style.left = ((coor.dx + coor.DW - dragBox.offsetWidth) >= 0 ? (coor.dx + coor.DW - dragBox.offsetWidth) : 0) + 'px';
        //
        //         moveLeft(coor, coor.x, coor.y);
        //         moveTop(coor, coor.x, coor.y);
        //         limitTop(coor, coor.x, coor.y);
        //         limitLeft(coor, coor.x, coor.y);
        //         setClip();
        //     }
        //     document.onmouseup = mouseUpClose;
        // }
        // 西南
        let pointSW = document.getElementById("point_sw");
        setEvent(pointSW, function(coor, e) {
            moveLeft(coor, coor.x, coor.y);
            moveDown(coor, coor.x, coor.y);
            scaling(getValueMin((coor.dx + dragBox.offsetWidth), (nativeImage.height - coor.dy)));
            limitLeft(coor, coor.x, coor.y);
            dragBox.style.left = (coor.dx + coor.DW - dragBox.offsetWidth) + 'px';
            dragBox.style.top = (coor.dy) + 'px';
        });
        // pointSW.onmousedown = function(ev) {
        //     console.log("缩放点");
        //     let coor = getCoordinate(ev);
        //     document.onmousemove = function(e) {
        //
        //         let dw = coor.diffX - e.clientX;
        //         let dh = coor.diffY - e.clientY;
        //         // dragBox.style.width = (dw > coor.dx) ? coor.dx + coor.DW : (dw + coor.DW) + 'px';
        //         // dragBox.style.height = (coor.DH - dh > nativeImage.height - coor.dy ? nativeImage.height - coor.dy : coor.DH - dh) + 'px';
        //         // dragBox.style.left = ((coor.dx + coor.DW - dragBox.offsetWidth) >= 0 ? (coor.dx + coor.DW - dragBox.offsetWidth) : 0) + 'px';
        //         moveLeft(coor, coor.x, coor.y);
        //         moveDown(coor, coor.x, coor.y);
        //         limitLeft(coor, coor.x, coor.y);
        //         setClip();
        //     }
        //     document.onmouseup = mouseUpClose;
        // }

        /**
         * dragBox.style.width = (coor.DW - dw > nativeImage.width - coor.dx ? nativeImage.width - coor.dx : coor.DW - dw) + 'px';
         * dragBox.style.height = (coor.DH + dh > coor.DH + coor.dy ? coor.DH + coor.dy : coor.DH + dh) + 'px';
         * dragBox.style.top = (coor.dy - dh < 0 ? 0 : coor.dy - dh) + 'px';
         * dragBox.style.height = (coor.DH - dh > nativeImage.height - coor.dy ? nativeImage.height - coor.dy : coor.DH - dh) + 'px';
         * dragBox.style.width = (dw > coor.dx) ? coor.dx + coor.DW : (dw + coor.DW) + 'px';
         * dragBox.style.left = ((coor.dx + coor.DW - dragBox.offsetWidth) >= 0 ? (coor.dx + coor.DW - dragBox.offsetWidth) : 0) + 'px';
         */

        function getValueMin(x, y) {
            return x < y ? x : y;
        }

        function scaling(max) {
            let value = dragBox.offsetWidth < dragBox.offsetHeight ? dragBox.offsetWidth : dragBox.offsetHeight;
            dragBox.style.width = (value < max ? value : max) + 'px';
            dragBox.style.height = (value < max ? value : max) + 'px';
        }

        // 上移
        function moveTop(coor) {
            dragBox.style.height = (coor.DH + coor.y > coor.DH + coor.dy ? coor.DH + coor.dy : coor.DH + coor.y) + 'px';
        }

        // 左移
        function moveLeft(coor) {
            dragBox.style.width = (coor.x > coor.dx) ? coor.dx + coor.DW : (coor.x + coor.DW) + 'px';
        }

        // 右移
        function moveRight(coor) {
            dragBox.style.width = (coor.DW - coor.x > nativeImage.width - coor.dx ? nativeImage.width - coor.dx : coor.DW - coor.x) + 'px';
        }

        // 下移
        function moveDown(coor) {
            dragBox.style.height = (coor.DH - coor.y > nativeImage.height - coor.dy ? nativeImage.height - coor.dy : coor.DH - coor.y) + 'px';
        }

        // 限制左移
        function limitLeft(coor) {
            dragBox.style.left = ((coor.dx + coor.DW - dragBox.offsetWidth) >= 0 ? (coor.dx + coor.DW - dragBox.offsetWidth) : 0) + 'px';
        }

        function limitTop(coor) {
            dragBox.style.top = (coor.dy - coor.y < 0 ? 0 : coor.dy - coor.y) + 'px';
        }

        // 按下鼠标时获取当前坐标
        function getCoordinate(e) {
            return {
                diffX: e.clientX,
                diffY: e.clientY,
                DW: dragBox.offsetWidth,
                DH: dragBox.offsetHeight,
                dx: dragBox.offsetLeft,
                dy: dragBox.offsetTop,
                x: 0,
                y: 0,
            };
        }

        // 裁剪窗口右边不能超出图片
        // function moveRight(e) {
        //     let maxW = viewImage.clientWidth - dragBox.offsetLeft - 2;
        //     let dragW = e.clientX - dragBox.getBoundingClientRect().left;
        //     dragBox.style.width = Math.min(Math.max(0, dragW), maxW) + 'px';
        // }
        //
        // // 裁剪窗口下边不能超出图片
        // function moveDown(e) {
        //     let maxH = viewImage.clientHeight - dragBox.offsetTop - 2;
        //     let dragH = e.clientY - dragBox.getBoundingClientRect().top;
        //     dragBox.style.height = Math.min(Math.max(0, dragH), maxH) + 'px';
        // }
        //
        // // 裁剪窗口左边不能超出图片
        // function moveLeft(e, maxLeft) {
        //     let maxW = dragBox.offsetLeft + dragBox.offsetWidth - 2;
        //     let disW = dragBox.getBoundingClientRect().left - e.clientX;
        //     dragBox.style.width = Math.min(Math.max(0, dragBox.clientWidth + disW), maxW) + 'px';
        //     dragBox.style.left = Math.max(Math.min(maxLeft, dragBox.offsetLeft - disW), 0) + 'px';
        // }
        //
        // // 裁剪窗口上边不能超出图片
        // function moveUp(e, maxTop) {
        //     let maxH = dragBox.offsetTop + dragBox.offsetHeight - 2;
        //     let disH = dragBox.getBoundingClientRect().top - e.clientY;
        //     dragBox.style.height = Math.min(Math.max(0, dragBox.clientHeight + disH), maxH) + 'px';
        //     dragBox.style.top = Math.max(Math.min(maxTop, dragBox.offsetTop - disH), 0) + 'px';
        // }


        /**
         * 使拖拽框长和宽等比例放大
         */
        // function scaleScaling() {
        //     // 计算图片长宽中较短的尺寸,作为预览框最大尺寸,防止预览框变形
        //     let max = viewImage.width < viewImage.height ? viewImage.width : viewImage.height;
        //     // 计算预览框长宽中较短的尺寸,作为预览框的拉伸尺寸,防止预览框拉出图片区域
        //     let size = dragBox.offsetWidth < dragBox.offsetHeight ? dragBox.offsetWidth : dragBox.offsetHeight;
        //     // console.log(max + "  -  " + size + "  -  " + dragBox.offsetWidth + "  -  " + dragBox.offsetHeight);
        //     dragBox.style.width = (size < max ? size : max) + 'px';
        //     dragBox.style.height = (size < max ? size : max) + 'px';
        //     setClip(); // 设置预览图相对位置
        // }


        // 为文件选择框绑定'onchange'事件
        selectInput.onchange = function() {
            let file = this.files[0];
            // 判断是文件是否为图片
            if ((file.type).indexOf("image/") >= 0) {
                // 使用'FileReader'读取文件
                let fr = new FileReader();
                fr.readAsDataURL(file);
                // 读取文件出现错误时,会调用'onerror'函数,不过暂时没想到怎么测试,就不管了
                fr.onerror = function() {
                    alert("读取文件出错！请重试！");
                };
                // 读取文件完成后,会调用'onload'函数
                fr.onload = function() {
                    // 图片读取完成后初始化预览图,拖拽框
                    initView(this);
                };

            } else {
                alert("你选择的文件不是图片哦~");
            }
        }

        /**
         * 图片读取完成后初始化预览图,拖拽框
         */
        function initView(fr) {
            // 因为我们选择图片时可能因为各种各样的原因,而不止选择一次,
            // 所以每次读取文件完成后都将'nativeImage'和'viewImage'指向的元素从DOM树中移除
            removeElement(nativeImage);
            removeElement(viewImage);

            // 创建一个新的Image
            nativeImage = new Image();
            // 'this.result'获取的是base64格式的字符串文件数据.data:image/jpeg;base64,/9j//gAQTG···
            // 直接将这个字符串赋值给image.src,即可在网页显示图片了
            nativeImage.src = fr.result;

            // 将图片添加到DOM树中
            nativeBox.appendChild(nativeImage);

            // 坑点一:
            // 必须要先调用[appendChild(Image)]将图片添加进DOM树,
            // 然后调用Image.width,Image.height才能获取到图片显示在网页中的尺寸,
            // 否则获取到的就会是图片的原始尺寸[Image.naturalWidth],[Image.naturalHeight]
            // 必须通过'Image'的'onload'方法等待图片加载完成后才能读取到图片添加到DOM树后的宽高
            nativeImage.onload = function() {
                // 为了防止出现裁剪区域变形或者遮罩层无法完整覆盖图片的情况
                // 将图片的高度赋值给图片图片预览框('nativeBox')和遮罩层('masking'),
                nativeBox.style.height = nativeImage.height + "px";
                masking.style.height = nativeImage.height + "px";

                console.log("W:" + nativeImage.width + "  -  H:" + nativeImage.height);
                console.log("W:" + nativeImage.naturalWidth + "  -  H:" + nativeImage.naturalHeight);

                // 创建预览图
                viewImage = new Image();
                viewImage.src = fr.result;
                viewImage.width = nativeImage.width; // 设置画布的宽度
                viewImage.height = nativeImage.height; // 设置画布的高度

                previewBox.appendChild(viewImage); // 将画布添加到DOM树中

                cropBoxWrap.style.height = viewImage.height + 'px';
                // 显示拖拽框
                dragBox.style.display = "block";
                // 初始化拖拽框位置
                dragBox.style.left = (viewImage.width / 2 - 50) + 'px';
                dragBox.style.top = (viewImage.height / 2 - 50) + 'px';
                setClip();


                // let ctx = viewImage.getContext("2d"); // 获取Context操作画布
                //
                // if (ctx) {
                //     // 坑点二: drawImage()函数有三种函数原型,其中第9个参数的位置有变动,刚开始不知道,被坑了
                //     // drawImage(image, dx, dy) 在画布指定位置绘制原图
                //     // drawImage(image, dx, dy, dw, dh) 在画布指定位置上按原图大小绘制指定大小的图
                //     // drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) 剪切图像，并在画布上定位被剪切的部分
                //
                //     // 第1个参数传一个Image对象,
                //     // 第2,3个参数是以画布和图片的左上角为基准定位图片再画布中的坐标(x,y)
                //     // 第4,5个参数是将图片以原始尺寸为基准,按照传入的尺寸按照比例添加到画布中
                //     // 例如:drawImage(Image, 0, 0, 200, 200),
                //     // 假设图片原始尺寸为1920x1080,画布尺寸为500x500
                //     // 显示到网页上的效果就是一张 500x500的图片,图片的左上角有一个200x200的原图,剩下的则是白框
                //     // 这里使用5个参数的原型,将图片添加进到画布中
                //     ctx.drawImage(nativeImage, 0, 0, nativeImage.width, nativeImage.height);
                //     ctx.save();
                //
                // }
            }
        }

    })();
</script>
</body>
</html>